DSA/
│
├── 1. Array/
│   ├── 1D Arrays (One-Dimensional Arrays)
│   ├── Multi-Dimensional Arrays
│   ├── Array Rotation
│   ├── Sliding Window Technique
│   ├── Two-Pointer Technique
│   ├── Bubble Sort
│   ├── Selection Sort
│   ├── Insertion Sort
│   ├── Quick Sort
│   ├── Counting Sort
│   ├── Radix Sort
│   ├── Merge Sort
│   ├── Linear Sort
│   └── Binary Sort
│
├── 2. String/
│   ├── String Manipulation
│   ├── Pattern Searching Algorithms (KMP, Rabin-Karp, Z Algorithm)
│   ├── Anagram and Palindrome Problems
│   └── Substring Search
│
├── 3. Linked List/
│   ├── Singly Linked List
│   ├── Doubly Linked List
│   ├── Circular Linked List
│   └── Circular Doubly Linked List
│
├── 4. Searching/
│   ├── Linear Search
│   ├── Binary Search (Iterative & Recursive)
│   ├── Ternary Search
│   ├── Exponential Search
│   ├── Jump Search
│   └── Interpolation Search
│
├── 5. Sorting/
│   ├── Bubble Sort
│   ├── Selection Sort
│   ├── Insertion Sort
│   ├── Merge Sort
│   ├── Quick Sort
│   ├── Heap Sort
│   ├── Radix Sort
│   ├── Counting Sort
│   ├── Bucket Sort
│   └── Shell Sort
│
├── 6. Divide and Conquer/
│   ├── Merge Sort
│   ├── Quick Sort
│   ├── Binary Search
│   └── Closest Pair of Points
│
├── 7. Stack/
│   ├── Array-Based Stack
│   ├── Linked List-Based Stack
│   ├── Two Stacks in One Array
│   ├── Stack Operations (Push, Pop, etc.)
│   ├── Infix, Prefix, Postfix Expression Conversion & Evaluation
│   ├── Balanced Parentheses Problem
│   ├── Stock Span Problem
│   └── Next Greater Element
│
├── 8. Queue/
│   ├── Simple Queue (Linear Queue)
│   ├── Circular Queue
│   ├── Priority Queue
│   ├── Deque (Double-Ended Queue)
│   ├── Blocking Queue
│   └── Double-Ended Priority Queue
│
├── 9. Tree/
│   ├── Binary Tree
│   ├── Binary Search Tree
│   ├── AVL Tree
│   ├── Segment Tree
│   ├── Fenwick Tree (Binary Indexed Tree)
│   ├── Trie (Prefix Tree)
│   ├── Tree Traversals (Inorder, Preorder, Postorder)
│   ├── Lowest Common Ancestor (LCA)
│   └── Height, Depth, and Diameter of Trees
│
├── 10. Graph/
│   ├── Graph Representation (Adjacency List, Adjacency Matrix)
│   ├── Graph Traversal (BFS, DFS)
│   ├── Shortest Path Algorithms (Dijkstra, Bellman-Ford, Floyd-Warshall)
│   ├── Minimum Spanning Tree (Prim’s, Kruskal’s)
│   ├── Topological Sorting
│   ├── Strongly Connected Components (Kosaraju, Tarjan's Algorithms)
│   ├── Bipartite Graph Checking
│   └── Bridges and Articulation Points
│
├── 11. Greedy/
│   ├── Fractional Knapsack Problem
│   ├── Activity Selection Problem
│   ├── Huffman Coding
│   ├── Job Sequencing Problem
│   ├── Coin Change Problem
│   └── Minimum Number of Platforms
│
├── 12. Recursion/
│   ├── Basic Recursion Problems
│   ├── Recursive Tree and Its Properties
│   ├── Tail Recursion
│   ├── Recursion vs. Iteration
│   └── Backtracking
│
├── 13. Backtracking/
│   ├── N-Queens Problem
│   ├── Sudoku Solver
│   ├── Rat in a Maze Problem
│   ├── Hamiltonian Cycle
│   ├── Subset Sum Problem
│   └── Permutations and Combinations
│
├── 14. Dynamic Programming/
│   ├── 0/1 Knapsack Problem
│   ├── Longest Common Subsequence (LCS)
│   ├── Longest Increasing Subsequence (LIS)
│   ├── Matrix Chain Multiplication
│   ├── Edit Distance
│   ├── Coin Change Problem
│   ├── Subset Sum Problem
│   ├── Rod Cutting Problem
│   └── Maximum Subarray Problem (Kadane’s Algorithm)
│
├── 15. Hashing/
│   ├── Hash Tables and Hash Functions
│   ├── Collision Resolution Techniques (Chaining, Open Addressing)
│   └── Applications (e.g., Anagram Grouping, Subarray with Given Sum)
│
└── 16. Heap/
    ├── Min-Heap and Max-Heap
    ├── Heap Operations (Insertion, Deletion, Heapify)
    ├── Heap Sort
    ├── Priority Queue
    ├── Kth Largest/Smallest Element Problems
    └── Merge k Sorted Arrays
